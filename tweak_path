#!/usr/bin/env bash

# $HOME/bin/login/tweak_path
# Lorin Ricker: bash functions to manipulate PATH

shF="$( basename ${0#-} ) - tweak_path"
Ident="${shF}  # (LMR version 1.03 of 09/12/2012)"
[ "$DEBUGMODE" = "1" ] && echo "%login-I, ${Ident}"

# ===============================================================
# Note: Each function definition includes an "export -f fname" so
#       that these are "global", copied to forked sub-processes
#       and can also be listed by Ruby script lsfunction.rb
# ================================================================

# These functions are adapted directly from the "Bash Cookbook"
# (Albing, Vossen & Newham, 2007 O'Reilly), Chapter 16, Recipes
# 16.3 and 16.4 --

# cookbook filename: func_pathmunge
# Adapted from Red Hat Linux

function pathmunge()
  {
    if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
      if [ "$2" = "after" ] ; then
        PATH="$PATH:$1"
      else
        PATH="$1:$PATH"
      fi
    fi
  }  # end function pathmunge
export -f pathmunge

# cookbook filename: func_tweak_path

# ==========
# Concatenate a directory to the beginning or end of your path,
# as long as it's not already present.
# Does not take into account symbolic links!
# Returns:  1 or sets the new $PATH
# Called like:  pathcat <directory> (pre|post)
function pathcat()
  {
    local location=$1
    local directory=$2

    # Make sure we have something to work with
    if [ -z "$location" -o  -z "$directory" ]; then
      echo "$0:$FUNCNAME: requires a location and a directory to add" >&2
      echo "e.g. pathcat pre $HOME/bin" >&2
      return 1
    fi

    # Make sure the directory is not relative
    if [ $( echo $directory | grep '^/' ) ]; then
      : echo "$0:$FUNCNAME: '$directory' is absolute" >&2
    else
      echo "$0:$FUNCNAME: can't add relative directory '$directory' to \$PATH" >&2
      return 1
    fi

    # Make sure the directory to add actually exists
    if [ -d "$directory" ]; then
      : echo "$0:$FUNCNAME: directory exists" >&2
    else
      echo "$0:$FUNCNAME: '$directory' does not exist--aborting" >&2
      return 1
    fi

    # Make sure it's not already in the PATH
    if [ $( pathcontains "$PATH" "$directory" ) ]; then
      echo "$0:$FUNCNAME: '$directory' already in \$PATH--aborting" >&2
    else
      : echo "$0:$FUNCNAME: adding directory to \$PATH" >&2
    fi

    # Figure out what to do
    case $location in
      pre*  ) PATH="$directory:$PATH" ;;
      post* ) PATH="$PATH:$directory" ;;
      *     ) PATH="$PATH:$directory" ;;
    esac

    # Clean up the new path, then set it
    PATH=$( pathclean $PATH )
  } # end function pathcat
export -f pathcat

# ==========
# Remove a directory from your path, if present.
# Returns:  sets the new $PATH
# Called like:  pathrm <directory>
function pathrm()
  {
    local directory=$1
    # Remove all instances of $directory from $PATH
    PATH=${PATH//$directory/}
    # Clean up the new path, then set it
    PATH=$( pathclean $PATH )
  } # end function pathrm
export -f pathrm

# ==========
# Remove leading/trailing or duplicate ':', remove duplicate entries
# Returns:  echos the "cleaned up" path
# Called like:  cleaned_path=$(pathclean $PATH)
function pathclean()
  {
    local path=$1
    local newpath
    local directory

    # Make sure we have something to work with
    [ -z "$path" ] && return 1

    # Remove duplicate directories, if any
    for directory in ${path//:/ }; do
      contains "$newpath" "$directory" && newpath="${newpath}:${directory}"
    done

    # Remove any leading, trailing &/or duplicate ':' separators
    newpath=$( echo $newpath | sed 's/^:*//; s/:*$//; s/::/:/g' )

    # Return the new path
    echo $newpath
  } # end function pathclean
export -f pathclean

# ==========
# Determine if the path contains a given directory;
# Return 1 if target is contained within pattern, 0 otherwise
# Called like:  pathcontains $PATH $dir
function pathcontains()
  {
    local pattern=":$1:"
    local target=$2
    # This will be a case-sensitive comparison unless nocasematch is set
    case $pattern in
      *:$target:* ) return 1 ;;
      *           ) return 0 ;;
    esac
  } # end function pathcontains
export -f pathcontains
